#!/usr/local/bin/perl
#
# Copyright (c) 2019 The NomadBSD Project. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
use utf8;
use strict;
use POSIX ":sys_wait_h";
use Time::HiRes "usleep";

binmode(STDOUT, ":utf8");
binmode(STDERR, ":utf8");

my $dummy;
my $xkbdlist		= "/usr/local/share/X11/xkb/rules/base.lst";
my $vtkbdlist		= "/usr/share/vt/keymaps/INDEX.keymaps";
my $path_zoneinfo	= "/usr/share/zoneinfo/zone.tab";
my $path_templates	= "/usr/share/nomadbsd-setup";
my $path_xkbd_conf	= "/usr/local/etc/X11/xorg.conf.d/10-input-keyboard.conf";
my $path_xinitrc	= "$path_templates/xinitrc";
my $path_scfb_cfg	= "/usr/local/etc/X11/xorg.conf.d/10-driver-scfb.conf";
my $path_vesa_cfg	= "/usr/local/etc/X11/xorg.conf.d/10-driver-vesa.conf";
my ($xlayoutstr, $xvariantstr);

my $cfg_timezone;
my $cfg_kbdlayout;
my $cfg_kbdvariant;
my @cfg_xkbdlayouts;
##############################################################################
# This section is for defining data.
#
# 
my %locales = (
	af_ZA	=>	'Afrikaans - South Africa',
	ar_AE	=>	'Arabic - United Arab Emirates',
	ar_EG	=>	'Arabic - Egypt',
	ar_JO	=>	'Arabic - Jordan',
	ar_MA	=>	'Arabic - Morocco',
	ar_QA	=>	'Arabic - Qatar',
	ar_SA	=>	'Arabic - Saudi Arabia',
	be_BY	=>	'Belarusian - Belarus',
	bg_BG	=>	'Bulgarian - Bulgaria',
	ca_ES	=>	'Catalan - Catalan',
	cs_CZ	=>	'Czech - Czech Republic',
	da_DK	=>	'Danish - Denmark',
	de_AT	=>	'German - Austria',
	de_CH	=>	'German - Switzerland',
	de_DE	=>	'German - Germany',
	el_GR	=>	'Greek - Greece',
	en_AU	=>	'English - Australia',
	en_CA	=>	'English - Canada',
	en_GB	=>	'English - United Kingdom',
	en_IE	=>	'English - Ireland',
	en_NZ	=>	'English - New Zealand',
	en_PH	=>	'English - Philippines',
	en_US	=>	'English - United States',
	en_ZA	=>	'English - South Africa',
	es_AR	=>	'Spanish - Argentina',
	es_CR	=>	'Spanish - Costa Rica',
	es_ES	=>	'Spanish - Spain',
	es_MX	=>	'Spanish - Mexico',
	et_EE	=>	'Estonian - Estonia',
	eu_ES	=>	'Basque - Basque',
	fi_FI	=>	'Finnish - Finland',
	fr_BE	=>	'French - Belgium',
	fr_CA	=>	'French - Canada',
	fr_CH	=>	'French - Switzerland',
	fr_FR	=>	'French - France',
	he_IL	=>	'Hebrew - Israel',
	hi_IN	=>	'Hindi - India',
	hr_HR	=>	'Croatian - Croatia',
	hu_HU	=>	'Hungarian - Hungary',
	hy_AM	=>	'Armenian - Armenia',
	is_IS	=>	'Icelandic - Iceland',
	it_CH	=>	'Italian - Switzerland',
	it_IT	=>	'Italian - Italy',
	ja_JP	=>	'Japanese - Japan',
	kk_KZ	=>	'Kazakh - Kazakhstan',
	ko_KR	=>	'Korean - Korea',
	lt_LT	=>	'Lithuanian - Lithuania',
	lv_LV	=>	'Latvian - Latvia',
	mn_MN	=>	'Mongolian - Mongolia',
	nb_NO	=>	'Norwegian (BokmÃ¥l) - Norway',
	nl_BE	=>	'Dutch - Belgium',
	nl_NL	=>	'Dutch - The Netherlands',
	nn_NO	=>	'Norwegian (Nynorsk) - Norway',
	pl_PL	=>	'Polish - Poland',
	pt_BR	=>	'Portuguese - Brazil',
	pt_PT	=>	'Portuguese - Portugal',
	ro_RO	=>	'Romanian - Romania',
	ru_RU	=>	'Russian - Russia',
	sk_SK	=>	'Slovak - Slovakia',
	sl_SI	=>	'Slovenian - Slovenia',
	sv_FI	=>	'Swedish - Finland',
	sv_SE	=>	'Swedish - Sweden',
	tr_TR	=>	'Turkish - Turkey',
	uk_UA	=>	'Ukrainian - Ukraine',
	zh_CN	=>	'Chinese - China',
	zh_HK	=>	'Chinese - Hong Kong SAR',
	zh_TW	=>	'Chinese - Taiwan'
);
##############################################################################

#
# Translate some X layout codes to vt(4) layout codes.
#
my %xklc_to_vtklc = qw(
	at			de
	gb			uk
	latam		latinamerican
);

#
# Translate some X keyboard variants to vt(4) keyboard variants.
#
my %xkv_to_vtkv = qw(
	mac			macbook
	dvorak-l	dvorakl
	dvorak-r	dvorakr
	de_mac		macbook
	fr_mac		macbook
	us-mac		macbook
	winkeys		win
);

#
# Write the given message to stderr and the log file, and terminate
# the script with exit 1.
#
sub bail {
	my ($msg) = @_;
	my $fh;

	$msg .= "\n";
	print STDERR $msg;
	exit 1
}

#
# Write a status message to stdout (the frontend). The frontend treats
# lines starting with a '!' as status messsage that tells the user what
# is happening.
#
sub status {
	my $ofh = select STDOUT;
	$| = 1;
	print "!$_[0] ...\n";
	select $ofh;
}

sub progress {
	my $ofh = select STDOUT;
	$| = 1;
	print "%$_[0]\n";
	select $ofh;
}

sub write_xorg_video_cfg {
	my $fh;
	my ($driver, $busID) = @_;
	if ($driver eq 'scfb') {
		open($fh, '+>', $path_scfb_cfg)
			or die("Couldn't write $path_scfb_cfg");
	} else {
		open($fh, '+>', $path_vesa_cfg)
			or die("Couldn't write $path_vesa_cfg");
	}
	print $fh qq(Section "Device"\n)     .
	      qq(    Identifier "Card0"\n)   .
	      qq(    Driver     "$driver"\n) .
	      qq(    BusID      "PCI:$busID"\n)  .
	      qq(EndSection\n);
	close $fh;
}

#
# Initialize environment for the graphical setup.
#
sub bootstrap_gui {
	my ($efiboot, $in_vgapci, $vbox, $path, $driver, $kms, $busID);
	my @spinner = qw(| / - \\);

	STDOUT->autoflush(1);
	print "Creating font cache. This might take a moment. " .
	      "The setup is starting soon.\n\n";
	if ((my $pid = fork()) == 0) {
		exec("/usr/local/bin/fc-cache");
	} else {
		my $n = 0;
		while (waitpid(-1, WNOHANG) >= 0) {
			print "\rPlease wait [$spinner[$n++]]";
			usleep(200000);
			$n = $n % @spinner;
		}
	}
	$ENV{XINITRC} = $path_xinitrc;
	$ENV{PATH}	  = "$ENV{PATH}:/usr/local/bin";
	exec("/usr/local/bin/xinit");
}

#
# Takes a reference to an array, and prints its content to stdout, while
# replacing the field delimiter tabs by a |.
#
sub print_array_data {
	my ($ref) = @_;
	foreach (@$ref) {
		$_ =~ s/\t+/|/;
		print "$_\n";
	}
}

#
# Print the list of locales sorted by name, not by locale code.
#
sub print_locales {
	foreach my $name (sort { $locales{$a} cmp $locales{$b} } keys %locales) {
		print "$name|$locales{$name}\n";
    }
}

#
# Print a sorted list of timezone records of the form:
#
#	timezone|region code
#
sub print_timezones {
	my @list;
	open(my $fh, '<', $path_zoneinfo) or die "$!";
	foreach (<$fh>) {
		next if (/^#/ || /^$/);
		chomp;
		my ($region, $unused, $tz) = split(/\t+/, $_);
		push @list, "$tz|$region";
	}
	close $fh;
	foreach (sort @list) {
		print "$_\n";
	}
}

#
# Check whether the given layout code matches a non-latin layout.
#
sub is_nonlatin {
	my @non_latin = qw(am ara ben bd bg bt by cs deva ge gh gr guj guru \
			   il in ir iku jp kan kh kr la lao lk mk mm mn mv \
			   mal olck ori pk ru scc sy syr tel th tj tam ua uz \
			   af et ma brai id iq kz kg my np rs tz);
	foreach (@non_latin) {
		return 1 if ($_[0] eq $_);
	}
	return 0;
}

#
# Print a list of records of the form:
#
#	lang code|lang name
#
# Example:
#
#	us|English (US)
#
sub print_kbdlayout_list {
	my ($latin) = @_;
	my ($in_layout, @layout_descs, @layouts, @tmplist);
	
	open(my $fh, '<', $xkbdlist) or die "$!";
	foreach (<$fh>) {
		chomp;
		if (/^\!\s+layout$/) {
			$in_layout  = 1;
		} elsif (/^\!/ && $in_layout) {
			last;
		} elsif ($in_layout) {
			if (/\s+(\S+)\s+(.*)$/) {
				next if ($latin && is_nonlatin($1));
				push @layout_descs, $2;
				push @layouts, $1;
			}
		}
	}
	close $fh;
	for (my $l; $l < @layouts; $l++) {
		push @tmplist, "$layout_descs[$l]|$layouts[$l]";
	}
	foreach (sort @tmplist) {
		my ($ld, $l) = split(/\|/, $_);
		# Layout code|Layout descr.
		print "$l|$ld\n";
	}
}

#
# Print a list of records of the form:
#
#	Variant code|variant descr.|layout code
#
# Example:
#
#	us|English (US)
#
sub print_kbdvariant_list {
	my ($layout) = @_;
	my ($in_variant, @variant_descs, @variant_layout);
	my (@variant_names, @tmplist);
	
	open(my $fh, '<', $xkbdlist) or die "$!";
	foreach (<$fh>) {
		chomp;
		if (/^\!\s+variant$/) {
			$in_variant = 1;
		} elsif (/^\!/ && $in_variant) {
			last;
		} elsif ($in_variant) {
			if (/\s+(\S+)\s+(\S+):\s+(.*)/) {
				next if ($layout && $layout ne $2);
				push @variant_descs, $3;
				push @variant_layout, $2;
				push @variant_names, $1;
			}
		}
	}
	close $fh;
	for (my $i = 0; $i < @variant_layout; $i++) {
		# Change order of fields, so that we can sort after layout
		# and variant description.
		my $rec = "$variant_descs[$i]|$variant_names[$i]|" .
				  "$variant_layout[$i]";
		push @tmplist, $rec;
	}
	foreach (sort @tmplist) {
		my ($vd, $vn, $l) = split(/\|/, $_);
		# Variant code|variant descr.|layout code
		print "$vn|$vd|$l\n";
	}
}

#
# Take a X keyboard layout code, and a X keyboard variant. 
# Return the best matching vt(4) keymap name.
#
sub xkbdtovt {
	my ($xl, $xv) = @_;
	my ($fallback, @vtkbdmaps);
	
	open(my $fh, '<', $vtkbdlist) or bail("Couldn't open $vtkbdlist");
	foreach (<$fh>) {
		chomp;
		push @vtkbdmaps, $1 if (/^([a-z-.]+\.kbd).*:en:.*/);
	}
	close $fh;
	# Resolve lang code.
	$xl = $xklc_to_vtklc{$xl} if ($xklc_to_vtklc{$xl});
	# Resolve variant name
	$xv = $xkv_to_vtkv{$xv} if ($xkv_to_vtkv{$xv});
	foreach (@vtkbdmaps) {
		my ($l, $v) = split(/\./, $_);
		return $_ if ($l eq $xl and $v eq $xv);
		# Use <lang code>.kbd as fallback if available.
		$fallback = $_ if ($l eq $xl and $v eq 'kbd');
	}
	return $fallback;
}

#
# Return a list of keyboard model names and their descriptions.
#
# Example record:
#	pc105|Generic 105-key PC (intl.)
#
sub print_xkbdmodels {
	my ($in_model, @models);

	open(my $fh, '<', $xkbdlist) or die "$!";
	foreach (<$fh>) {
		if (/^\!\s+model$/) {
			$in_model = 1;
		} elsif (/^\!/ && $in_model) {
			last;
		} elsif ($in_model) {
			# Swap description and ID/code in order to sort the list.
			push @models, "$2|$1" if (/\s+(\S+)\s+(.*)$/);
		}
	}
	close $fh;
	foreach (sort @models) {
		my ($d, $c) = split(/\|/, $_);
		print "$c|$d\n";
	}
}

sub set_timezone {
	my ($tz) = @_;
	# This needs fixing
	system("echo $tz > /var/db/zoneinfo");
	system("cp /usr/share/zoneinfo/$tz /etc/localtime");
	system("adjkerntz -i");
}

sub set_kbdmap {
	my $vtkbdmap = xkbdtovt($cfg_kbdlayout, $cfg_kbdvariant);
	open(my $in, "<$path_templates/input-keyboard.conf") or
		bail("Couldn't open $path_templates/input-keyboard.conf");
	open(my $out, ">$path_xkbd_conf")
		or bail("Couldn't open $path_xkbd_conf");
	$xlayoutstr  .= $cfg_kbdlayout;
	$xvariantstr .= $cfg_kbdvariant;
	for (my $l = 0; $l < @cfg_xkbdlayouts; $l++) {
		my @lv = split(/\t/, $cfg_xkbdlayouts[$l]);
		$xlayoutstr  .= ',';
		$xvariantstr .= ',';
		$xlayoutstr  .= $lv[0];
		$xvariantstr .= $lv[1];
	}
	foreach (<$in>) {
		$_ =~ s/\@XKBDLAYOUT\@/$xlayoutstr/;
		$_ =~ s/\@XKBDVARIANT\@/$xvariantstr/;
		print $out $_;
	}
	close($in); close($out);
	system("kbdcontrol -l $vtkbdmap");
	system("sysrc -f /etc/rc.conf.in keymap=$vtkbdmap");
}

#
# Read the configuration from stdin, and do the installation
#
sub commit {
	my ($nfiles, $n);

	while ($_ = <STDIN>) {
		my $ofh = select STDIN;
		$| = 1;
		select $ofh;
		chomp;
		$cfg_timezone	   = $1 if (/^cfg_timezone\s*=\s*(.*)/);
		$cfg_kbdlayout	   = $1 if (/^cfg_kbdlayout\s*=\s*(.*)/);
		$cfg_kbdvariant	   = $1 if (/^cfg_kbdvariant\s*=\s*(.*)/);
		if (/^cfg_xkbdlayouts\s*=\s*(.*)/) {
			@cfg_xkbdlayouts = split(/,/, $1);
		}
	}
	STDOUT->autoflush(1);
	if ($dummy) {
		dummy_commit();
		exit 0;
	}
	status("Copying $path_templates/rc.conf.in to /etc/rc.conf.in");
	system("cp $path_templates/rc.conf.in /etc/rc.conf.in");
	status("Setting timezone");
	set_timezone($cfg_timezone);
	system("cap_mkdb /etc/login.conf");
	status("Setting keyboard map for X and vt");
	set_kbdmap();
	system("sysrc -e initgfx_kmods >> /etc/rc.conf.in");
	system("mv /etc/rc.conf.in /etc/rc.conf");
	system("touch /etc/wpa_supplicant.conf");
	status("Regenerating font cache");
	system("/usr/local/bin/fc-cache -sfr");
	unlink($path_vesa_cfg);
	unlink($path_scfb_cfg);
	system("rm -rf /root/.config/autostart");
	exit 0;
}

sub dummy_commit {
	status("Copying $path_templates/rc.conf.in to /etc/rc.conf.in");
	status("Setting timezone $cfg_timezone");
	status("Setting keyboard map ($cfg_kbdlayout, $cfg_kbdvariant) " .
		   "for X and vt");
	exit 0;
}

sub usage {
	print "Usage: nomadbsd-setup [options] command [args ...]\n" .
		  "OPTIONS\n" .
		  "-h             Print this\n" .
		  "-n             Dummy mode. Only writes messages to stdout\n" .
		  "               without doing anything\n" .
		  "COMMANDS\n" .
		  "locales        Print list of locales\n" .
		  "filemanagers   Print a list of file managers\n" .
		  "editors        Print a list of editors\n" .
		  "guieditors     Print a list of GUI editors\n" .
		  "kbdmodels      Print a list of X keyboard models\n" .
		  "kbdlayouts     Print a list of keyboard layouts\n" .
		  "kbdvariants    Print a list of keyboard varinats\n" .
		  "timezones      Print a list of time zones\n" .
		  "commit         Read configuration from stdin, and apply it\n" .
		  "               to the device.\n" .
		  "bootstrap-gui  Set up an X server and start the front end\n";
		exit 0;
}

#
# Take an array of flag character and the expected number of arguments.
# If $ARGV[0] containes a flag not in the given array, or @ARGV doesn't
# have the required number of arguments, exit with an error.
# If $ARGV[0] contains a valid flag and @ARGV has the expected number of
# arguments, return the flag character. If $ARGV[0] doesn't start with
# a '-', return an empty string.
#
sub check_args {
	my $nargs;
	if ($ARGV[0] =~ /^-([A-Za-z0-9])([A-Za-z0-9]+)/) {
		# -Xarg
		$nargs = @ARGV;
		for (my $i = 0; $i < @_ - 1; $i++) {
			next if ($_[$i] ne $1);
			if ($_[$i + 1] == 0) {
				# An argument was given, but this option doesn't
				# expect an argument.
				print STDERR "-$_[$i] has no arguments\n";
				exit 1;
			}
		}
	} elsif ($ARGV[0] =~ /^-([A-Za-z0-9]{1})/) {
		# -X
		$nargs = @ARGV - 1;
	} else {
		return "";
	}
	for (my $i = 0; $i < @_ - 1; $i++) {
		next if ($_[$i] ne $1);
		if ($nargs < $_[$i + 1]) {
			print STDERR "Option -$_[$i] requires $_[$i + 1] arguments\n";
			exit 1;
		}
		for (my $j = 0; $j + 1 < $nargs && $j < $_[$i + 1]; $j++) {
			if ($ARGV[$j + 1] =~ /^-/) {
				print STDERR "Option -$_[$i] requires $_[$i + 1] arguments\n";
				exit 1
			}
		}
		return $1;
	}
	print STDERR "Invalid option '$ARGV[0]'\n";
	exit 1;
}

while ((my $flag = check_args('h', 0, 'n', 0))) {
	usage()	   if ($flag eq 'h');
	$dummy = 1 if ($flag eq 'n');
	shift;
}

while (@ARGV) {
	if ($ARGV[0] eq "locales") {
		print_locales();
		exit 0;
	} elsif ($ARGV[0] eq "kbdlayouts") {
		shift @ARGV;
		my $f = check_args('l', 0);
		if ($f eq 'l') {
			print_kbdlayout_list(1);
		} else {
			print_kbdlayout_list(0);
		}
		exit 0;
	} elsif ($ARGV[0] eq "kbdmodels") {
		print_xkbdmodels();
		exit 0;
	} elsif ($ARGV[0] eq "kbdvariants") {
		my $variant;
		
		shift @ARGV;
		my $f = check_args('l', 1);
		if ($f eq 'l') {
			shift;
			$variant = pop @ARGV;
		}
		print_kbdvariant_list($variant);
		exit 0;
	} elsif ($ARGV[0] eq "timezones") {
		print_timezones();
		exit 0;
	} elsif ($ARGV[0] eq "commit") {
		commit();
		exit 0;
	} elsif ($ARGV[0] eq "bootstrap-gui") {
		bootstrap_gui();
		exit 0;
	} else {
		print STDERR "Unknown command: $ARGV[0]\n";
		usage();
	}
	shift;
}
usage();
