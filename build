#!/bin/sh
#
# vim: set tabstop=4:
#
# Copyright (c) 2021, The NomadBSD Project
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

# COMMANDS
#
# all		 Set up base system, build and install kernel if BUILD_KERNEL is
#			 set to YES, intall packages, ports, software from Git repos.
#
# initbase	 Create nomad user, and copy all configuration files from
#			 config/ and nomad/ to base system.
#
# handbook	 Build and install the NomadBSD handbook.
#
# ports		 Build and install all ports defined in build.cfg
#
# pkgs		 Install all packages from pkg.list
#
# git		 Install software from Git repos defined in build.cfg
#
# pkgcfg	 Set up configuration files and users required by installed
#			 software packages.
#
# resume	 Continue where the build failed.
#
# setupgui	 (Re)build and (re)install nomadbsd-setup-gui
#
# installgui (Re)build and (re)install nomadbsd-install-gui
#
# dmconfig	 (Re)build and (re)install nomadbsd-dmconfig-gui
#

. ./build.cfg
set -x

case ${RELEASE##*-} in
RELEASE|BETA|RC*)
	URL="${BASEURL}/releases";;
*)
	URL="${BASEURL}/snapshots";;
esac

# Where bsdinstall stores fetched files.
DISTDIR="/tmp"
XORG_CONF_D="${SYSDIR}/usr/local/etc/X11/xorg.conf.d"
FONTSDIR="${SYSDIR}/usr/local/share/fonts"
FONTPATHS_FILE="${XORG_CONF_D}/files.conf"
DISTSITE=${URL}/${ARCH}/${RELEASE}
KERNCONF_DIR="${SYSDIR}/usr/src/sys/${ARCH}/conf"
KERNCONF_NOMADBSD="${KERNCONF_DIR}/NOMADBSD"
KERNCONF_GENERIC="${KERNCONF_DIR}/GENERIC"

initbase()
{
	chroot "${SYSDIR}" sh -c 'mount -t devfs devfs /dev'
	chroot "${SYSDIR}" sh -c '/etc/rc.d/ldconfig start'
	umount "${SYSDIR}/dev"
	(cd config && tar cf - .) | \
	    (cd "${SYSDIR}" && tar -xf - --uname root --gname wheel)
	chroot "${SYSDIR}" sh -c 'cap_mkdb /etc/login.conf'
	insthandbook
	if (echo ${RELEASE} | grep -q 'CURRENT'); then
		sed -E -i '' 's/quarterly/latest/g' "${SYSDIR}/etc/pkg/FreeBSD.conf"
		rm -f "${SYSDIR}/usr/local/etc/X11/xorg.conf.d/wacom.conf"
	fi
	# Set boot menu position in ${SYSDIR}/boot/lua/drawer.lua
	re="s/^menu_position =.*$/menu_position"
	re="${re} = {x = ${MENU_POSITION_X}, y = ${MENU_POSITION_Y}}/"
	sed -E -i '' "${re}" "${SYSDIR}"/boot/lua/drawer.lua
	# Disable uart.1 to prevent hangs on CherryTrail systems
	sed -E -i '' 's/^(hint\.uart\.1.*)/#\1/g' "${SYSDIR}"/boot/device.hints
	# Add mdns to "hosts:" line in /etc/nsswitch.conf
	if ! grep -q 'hosts:.*mdns*' "${SYSDIR}"/etc/nsswitch.conf; then
		sed -E -i '' 's/^(hosts:) (.*)/\1 \2 mdns/' \
			"${SYSDIR}"/etc/nsswitch.conf
	fi
}

mkfontpaths()
{
	[ ! -d "${XORG_CONF_D}" ] && mkdir -p "${XORG_CONF_D}"

	for i in "${FONTSDIR}"/*; do
		[ ! -d "$i" ] && continue
		mkfontscale "$i/"
		mkfontdir "$i/"
	done
	(echo "Section \"Files\""
	IFS=
	for i in "${FONTSDIR}"/*; do \
		[ ! -d "$i" ] && continue
		n=$(head -1 "$i/fonts.scale")
		r="s#${SYSDIR}(/.*)\$#\\1#"
		i=$(echo $i | sed -E $r)
		if [ $n -gt 0 ]; then \
			echo "  FontPath \"$i\""
		else
			if [ ! -z ${ns} ]; then
				ns=$(printf "${ns}\n$i")
			else
				ns="$i"
			fi
		fi
	done
	echo ${ns} | while read i; do \
		echo "  FontPath \"$i\""
	done
	echo "EndSection") > "${FONTPATHS_FILE}"
}

installsrc()
{
	local version srcurl

	[ ! -d "${SYSDIR}" ] && mkdir -p "${SYSDIR}" || bail
	fetch ${DISTSITE}/src.txz -o /tmp/src.txz || bail
	tar --unlink -xvpJf /tmp/src.txz -C "${SYSDIR}" || bail
	rm -f /tmp/src.txz
}

updatebase()
{
	PAGER=cat freebsd-update --currently-running ${RELEASE} \
		-f "${SYSDIR}/etc/freebsd-update.conf" -b "${SYSDIR}" \
		-d "${SYSDIR}/var/db/freebsd-update" fetch && \
	PAGER=cat freebsd-update --currently-running ${RELEASE} \
		-f "${SYSDIR}/etc/freebsd-update.conf" -b "${SYSDIR}" \
		-d "${SYSDIR}/var/db/freebsd-update" install
}

buildnvidia()
{
	local d v pkgname have_gsed

	[ ! -d "${SYSDIR}/usr/ports" ] && mkdir "${SYSDIR}/usr/ports"
	if ! (mount | grep -q "${SYSDIR}/usr/ports"); then
		mount -t nullfs "${PORTSTREE}" "${SYSDIR}/usr/ports"
	fi
	if ! (mount | grep -q "${SYSDIR}/dev"); then
		chroot "${SYSDIR}" sh -c 'mount -t devfs devfs /dev'
	fi
	# Building nvidia-driver>=410 requires textproc/gsed
	if pkg --chroot "${SYSDIR}" info --exists textproc/gsed; then
		have_gsed=1
	else
		pkg --chroot "${SYSDIR}" install -y textproc/gsed
	fi
	for v in 304 340 390 latest; do
		# Skip nvidia-driver>=440 on i386
		[ ${ARCH} = "i386" -a $v = "latest" ] && continue
		if [ $v = "latest" ]; then
			d="nvidia-driver"
		else
			d="nvidia-driver-$v"
		fi
		pkgname=$(cd "${PORTSTREE}/x11/$d" && make -VPKGNAME)
		[ -f "${PKGDIR}/${pkgname}.txz" ] && continue
		chroot "${SYSDIR}" sh -c "cd /usr/ports/x11/$d && \
			make BATCH=1 ${NVIDIA_BUILD_OPTS} clean package" || bail
		mkdir -p "${SYSDIR}/usr/local/nvidia/$v" 2>/dev/null
		cat "${SYSDIR}/usr/ports/x11/$d/work/pkg/${pkgname}.txz" | \
			(cd "${SYSDIR}/usr/local/nvidia/${v}" && tar xf -)
		chroot "${SYSDIR}" sh -c "cd /usr/ports/x11/$d && make distclean"
	done
	# Remove textproc/gsed if we just installed it for building nvidia-driver
	[ -z "${have_gsed}" ] && pkg --chroot "${SYSDIR}" delete -y textproc/gsed
	umount "${SYSDIR}/usr/ports"
	umount "${SYSDIR}/dev"
	mkdir -p "${SYSDIR}"/nvidia/usr/local/lib/xorg/modules/drivers
	mkdir -p "${SYSDIR}"/nvidia/usr/local/lib/xorg/modules/extensions

	rm -f "${SYSDIR}/usr/local/lib/xorg/modules/drivers/nvidia_drv.so"
	ln -sf "/nvidia/usr/local/lib/xorg/modules/drivers/nvidia_drv.so" \
		"${SYSDIR}/usr/local/lib/xorg/modules/drivers/"
	for l in libglx.so libglx.so.1 libglxserver_nvidia.so \
			 libglxserver_nvidia.so.1; do
		rm -f "${SYSDIR}/usr/local/lib/xorg/modules/extensions/$l"
		ln -sf "/nvidia/usr/local/lib/xorg/modules/extensions/$l" \
			"${SYSDIR}/usr/local/lib/xorg/modules/extensions/"
	done
}

pkglist()
{
	if [ ${ARCH} = "i386" ]; then
		awk '
			!/virtualbox-ose-additions/ {
				print $0
			}
		' < ${PKGLIST}
	else
		cat ${PKGLIST}
	fi
}

instpkgs()
{
	if ! (mount | grep -q "${SYSDIR}/dev"); then
		chroot "${SYSDIR}" sh -c 'mount -t devfs devfs /dev'
	fi
	export ASSUME_ALWAYS_YES=yes
	pkglist | xargs -J% pkg -c "${SYSDIR}" install -y % || bail

	# Lock all kernel module packages to prevent kernel version mismatch
	# problems when updating packages on CURRENT.
	if (echo ${RELEASE} | grep -q 'CURRENT'); then
		pkg -c "${SYSDIR}" lock -y -g '*-kmod-*'
	fi
	umount "${SYSDIR}/dev"
}

instgit()
{
	[ ! -d "${SYSDIR}/tmp/git" ] && mkdir "${SYSDIR}/tmp/git"
	if ! (mount | grep -q "${SYSDIR}/dev"); then
		chroot "${SYSDIR}" sh -c 'mount -t devfs devfs /dev'
	fi
	for r in ${GIT_REPOS}; do
		rd=$(echo $r | sed -E 's#.*/(.*)\.git$#\1#')
		repo_dirs="${repo_dirs} ${rd}"
		if [ ! -d "${SYSDIR}/tmp/git/${rd}" ]; then
			chroot "${SYSDIR}" sh -c "cd /tmp/git && git clone ${r}"
		fi
	done
	for r in ${repo_dirs}; do
		rname=$(echo $r | tr '-' '_')
		eval build_cmd=\${${rname}_BUILD_CMD}
		[ -z "${build_cmd}" ] && continue
		chroot "${SYSDIR}" sh -c "cd /tmp/git/${r}; ${build_cmd}"
	done
	umount "${SYSDIR}/dev"
}

postpkgcfg()
{
	cp "${SYSDIR}/usr/local/etc/dsbmd.conf.sample" \
		"${SYSDIR}/usr/local/etc/dsbmd.conf"
	if grep -q ^cups: "${SYSDIR}/etc/group"; then
		chroot "${SYSDIR}" sh -c 'pw groupmod cups -m nomad'
	fi
	if grep -q ^webcamd: "${SYSDIR}/etc/group"; then
		chroot "${SYSDIR}" sh -c 'pw groupmod webcamd -m nomad'
	fi
	# Remove desktop files for LXDE and Xfce preferred applications
	rm -f "${SYSDIR}"/usr/local/share/applications/exo-*.desktop
	rm -f "${SYSDIR}"/usr/local/share/applications/libfm-pref-apps.desktop

	# Remove useless Xfce desktop file
	rm -f "${SYSDIR}"/usr/local/share/applications/xfce4-about.desktop

	# Remove Networkmgr's netcardmgr script which messes with our auto-
	# configured network interfaces in /etc/rc.conf.
	rm -f "${SYSDIR}"/usr/local/bin/netcardmgr

	# Use the Papirus terminal icon as default icon for Sakura
	cp "${SYSDIR}"/usr/local/share/icons/Papirus/48x48/apps/utilities-terminal.svg \
	"${SYSDIR}"/usr/local/share/pixmaps/terminal.svg
	(cd config/usr/local/share/slim && tar cf - .) | \
	    (cd "${SYSDIR}"/usr/local/share/slim && tar xf -)
	mkfontpaths
}

#
# Check if the port options of an installed package matches
# the given options. Options are defined as follows:
# "OPT1=<on|off> OPT2=<on|off> ... OPTn=<on|off>"
# Return != 0 if the value of one of the given options do not
# match the returned (pkg query) options.
#
check_port_opts()
{
	local port=$1
	local opts=$2
	local curopts=$(pkg -c ${SYSDIR} query -i "%Ok=%Ov" ${port})

	for o in ${opts}; do
		if ! (echo ${curopts} | grep -q $o); then
			return 1
		fi
	done
	return 0
}

#
# Creates a port's _SET and _UNSET make variables from a list
# of OPT=<on|off> pairs.
#
# Example: port_popts cat/fooport "FOO=on BAR=off BAZ=on"
#          becomes cat_fooport_SET="FOO BAZ" cat_fooport_UNSET="BAR"
#
port_opts()
{
	local popts=$2
	local pname=$(echo $1 | tr '/' '_')

	echo ${popts} | tr ' ' '\n' | awk -v pname=${pname} '{
		split($0, a, /=/);
		if (a[2] ~ /on/) {
			set_vars = sprintf("%s%s%s", set_vars,
			    set_vars ? " " : "", a[1]);
		} else if (a[2] ~ /off/) {
			unset_vars = sprintf("%s%s%s", unset_vars,
			    unset_vars ? " " : "", a[1]);
		}
	}
	END {
		if (set_vars)
			printf("%s_SET=\"%s\" ", pname, set_vars);
		if (unset_vars)
			printf("%s_UNSET=\"%s\"", pname, unset_vars);
	}'
}

instports()
{
	[ ! -d "${SYSDIR}/usr/ports" ] && mkdir "${SYSDIR}/usr/ports"
	if ! (mount | grep -q "${SYSDIR}/usr/ports"); then
		mount -t nullfs "${PORTSTREE}" "${SYSDIR}/usr/ports"
	fi
	if ! (mount | grep -q "${SYSDIR}/dev"); then
		chroot "${SYSDIR}" sh -c 'mount -t devfs devfs /dev'
	fi
	#
	# We need devel/autoconf and devel/automake to build
	# sysutils/fusefs-jmtpfs
	#
	if pkg --chroot "${SYSDIR}" info --exists devel/autoconf; then
		have_autoconf=1
	else
		pkg --chroot "${SYSDIR}" install -y devel/autoconf
	fi
	if pkg --chroot "${SYSDIR}" info --exists devel/automake; then
		have_automake=1
	else
		pkg --chroot "${SYSDIR}" install -y devel/automake
	fi
	for p in ${PORTSLIST}; do
		echo "Checking whether $p is already installed" >&2
		pname=$(echo $p | cut -d/ -f2 | tr '.-' '__')
		eval popts=\${${pname}_OPTS}
		if pkg --chroot "${SYSDIR}" info --exists $p; then
			if check_port_opts $p "${popts}"; then
				# Port options not changed. Check whether the ports
				# version is newer than the installed version.
				p1=$(pkg --chroot "${SYSDIR}" info $p | head -1)
				p2=$(cd ${SYSDIR}/usr/ports/$p && make -VPKGNAME);
				result=$(pkg version -t $p2 $p1)
				[ $result = '<' -o $result = '=' ] && continue
				echo "Building newer version from ports ..."
			else
				echo "Options of installed package do not match."
			fi
		fi
		echo "Building $p ..." >&2
		local opts=$(port_opts $p "${popts}")
		chroot "${SYSDIR}" sh -c "cd /usr/ports/$p && \
			make BATCH=1 ${opts} clean deinstall install" || bail
	done
	# Lock all kernel module packages to prevent kernel version mismatch
	# problems when updating packages on CURRENT.
	if (echo ${RELEASE} | grep -q 'CURRENT'); then
		pkg -c "${SYSDIR}" lock -y -g '*-kmod-*'
	fi
	# Delete packages needed to build the ports
	if [ -z "$have_autoconf" ]; then
		pkg -c "${SYSDIR}" delete -y devel/autoconf
	fi
	if [ -z "$have_automake" ]; then
		pkg -c "${SYSDIR}" delete -y devel/autoconf
	fi
	pkg -c "${SYSDIR}" autoremove -y

	umount "${SYSDIR}/usr/ports"
	umount "${SYSDIR}/dev"
}

buildkernel()
{
	local makeopts="KERNCONF=NOMADBSD ${BUILDKERNEL_OPTS}"
	      makeopts="${makeopts} WITHOUT_MODULES=\"${WITHOUT_KMODS}\""
	local regx="/DEBUG=-g/d; /WITH_CTF=1/d; /^ident.*GENERIC/d;"
	sed -e "${regx}" < ${KERNCONF_GENERIC} > ${KERNCONF_NOMADBSD}
	KERNELOPTS >> ${KERNCONF_NOMADBSD}
	if [ "${ARCH}" = "i386" ]; then
		makeopts="${makeopts} LD=ld.lld"
	fi
	for i in $(pwd)/patch/usr/src/*.diff; do
		(cd "${SYSDIR}"/usr/src && patch -N < $i)
	done
	chroot "${SYSDIR}" sh -c "mount -t devfs devfs /dev; \
	    cd /usr/src && make ${makeopts} kernel" || bail
	umount "${SYSDIR}/dev"
}

instsrcdist()
{
	BSDINSTALL_DISTDIR="${DISTDIR}" DISTRIBUTIONS=src.txz \
	    BSDINSTALL_DISTSITE=${DISTSITE} bsdinstall distfetch
	BSDINSTALL_DISTDIR="${DISTDIR}" BSDINSTALL_CHROOT="${SYSDIR}" \
	    DISTRIBUTIONS=src.txz bsdinstall distextract
}

build_setupgui()
{
	if [ "${ARCH}" = "mac" ]; then
		QMAKE_VARS="MAC=1"
	else
		QMAKE_VARS=""
	fi
	cp -a src/nomadbsd-setup-gui "${SYSDIR}/tmp/"
	chroot "${SYSDIR}" sh -c "mount -t devfs devfs /dev; \
		cd /tmp/nomadbsd-setup-gui && make distclean; \
		qmake-qt5 ${QMAKE_VARS} && make && make install" || bail
	umount "${SYSDIR}/dev"
}

build_installgui()
{
	if [ "${ARCH}" = "mac" ]; then
		QMAKE_VARS="MAC=1"
	else
		QMAKE_VARS=""
	fi
	cp -a src/nomadbsd-install-gui "${SYSDIR}/tmp/"
	chroot "${SYSDIR}" sh -c "mount -t devfs devfs /dev; \
		cd /tmp/nomadbsd-install-gui && make distclean; \
		qmake-qt5 ${QMAKE_VARS} && make && make install" || bail
	umount "${SYSDIR}/dev"
}

build_addusergui()
{
	if [ ! -d "${SYSDIR}/usr/share/nomadbsd" ]; then
		mkdir -p "${SYSDIR}/usr/share/nomadbsd"
	fi
	(cd nomad && tar cfz - .) > \
		"${SYSDIR}/usr/share/nomadbsd/home.nomad.tgz"
	cp -a src/nomadbsd-adduser-gui "${SYSDIR}/tmp/"
	chroot "${SYSDIR}" sh -c "mount -t devfs devfs /dev; \
		cd /tmp/nomadbsd-adduser-gui && make distclean; \
		qmake-qt5 && make && make install" || bail
	umount "${SYSDIR}/dev"
}

build_dmconfig()
{
	cp -a src/nomadbsd-dmconfig "${SYSDIR}/tmp/"
	chroot "${SYSDIR}" sh -c "mount -t devfs devfs /dev; \
		cd /tmp/nomadbsd-dmconfig && make distclean; \
		qmake-qt5 && make && make install" || bail
	umount "${SYSDIR}/dev"
}

build_chusr()
{
	cp -a src/nomadbsd-chusr "${SYSDIR}/tmp/"
	chroot "${SYSDIR}" \
			sh -c "cd /tmp/nomadbsd-chusr && make install" || bail
}

build_lbi_gui()
{
	cp -a src/lbi-gui "${SYSDIR}/tmp/"
	chroot "${SYSDIR}" sh -c "mount -t devfs devfs /dev; \
		cd /tmp/lbi-gui && make && make install" || bail
	umount "${SYSDIR}/dev"
}

insthandbook()
{
	local i

	if [ ! -d "${WORKDIR}/handbook" ]; then
		git clone https://github.com/nomadbsd/handbook.git \
			"${WORKDIR}/handbook"
	else
		(cd "${WORKDIR}/handbook" && git pull)
	fi
	(cd "${WORKDIR}/handbook" && make)
	if [ ! -d "${SYSDIR}/usr/share/nomadbsd-handbook" ]; then
		mkdir "${SYSDIR}/usr/share/nomadbsd-handbook"
	fi
	for i in style.css handbook.html images; do
		cp -r "${WORKDIR}/handbook/$i" "${SYSDIR}/usr/share/nomadbsd-handbook/"
	done
}

runsetup()
{
	service initgfx onestart
	/usr/libexec/nomadbsd-setup bootstrap-gui
}

bail()
{
	exit 1
}

save_stage()
{
	echo "ARCH=${ARCH}" > ".failed-stage"
	echo "__stage=$1" >> ".failed-stage"
}

restore_stage()
{
	. ./.failed-stage
}

all()
{
	local i stages

	stages="instpkgs instgit build_setupgui build_installgui build_addusergui"
	stages="${stages} build_dmconfig build_chusr build_lbi_gui "
	stages="${stages} instports buildnvidia postpkgcfg runsetup"
	initbase
	instsrcdist
	save_stage "instsrcdist"

	# Do not run freebsd-update on STABLE or CURRENT.
	if ! (echo ${RELEASE} | grep -Eq 'STABLE|CURRENT'); then
		save_stage updatebase
		updatebase
	fi 
	if [ ! -z "${BUILD_KERNEL}" ]; then
		case ${BUILD_KERNEL} in
		[yY][eE][sS])
			save_stage buildkernel
			buildkernel
			;;
		esac
	fi
	for i in ${stages}; do
		save_stage "$i"
		$i
	done
	rm -f ".failed-stage"
}

resumebuild()
{
	stages="instsrcdest updatebase buildkernel instpkgs instgit build_setupgui"
	stages="${stages} build_installgui build_addusergui"
	stages="${stages} build_dmconfig build_chusr build_lbi_gui "
	stages="${stages} instports buildnvidia postpkgcfg runsetup"

	stage_found=0
	restore_stage
	failed_stage=$__stage
	if [ -z "${failed_stage}" ]; then
		echo "There is nothing to continue" >&2
		exit 1
	fi
	for i in ${stages}; do
		if  [ ${stage_found} -eq 1 ]; then
			save_stage "$i"
			$i
		elif [ "${failed_stage}" = $i ]; then
			stage_found=1
			$i
		fi
	done
	rm -f ".failed-stage"
}

usage()
{
	echo "Usage: build cmd ..."
	echo "       build -h"
	exit 1
}

help()
{
	less build.hlp
	exit 0
}

[ $# -lt 1 ] && usage

if ! which mkfontscale >/dev/null;  then
	echo "Installing mkfontscale ..."
	pkg install -y x11-fonts/mkfontscale || bail
fi
if ! which markdown >/dev/null; then
	echo "Installing markdown ..."
	pkg install -y textproc/markdown || bail
fi
if ! which git >/dev/null; then
	echo "Installing git ..."
	pkg install -y devel/git || bail
fi
if [ ! -f /usr/ports/Makefile ]; then
	echo "Installing ports tree ..."
	git clone https://git.freebsd.org/ports.git /usr/ports || bail
fi

trap bail SIGINT SIGTERM SIGHUP

while [ $# -gt 0 ]; do
	case "$1" in
	-a)
		shift
		[ $# -eq 0 ] && usage
		ARCH=$1
		;;
	-h)
		help;;
	-*)
		echo "Invalid option '$1'" >&2
		usage
		;;
	*)
		break
		;;
	esac
	shift
done


while [ $# -gt 0 ]; do
	case "$1" in
	all)		all;;
	git)		instgit;;
	handbook)	insthandbook;;
	initbase)	initbase;;
	kernel)		buildkernel;;
	pkgcfg)		postpkgcfg;;
	pkgs)		instpkgs;;
	ports)		instports;;
	resume)		resumebuild;;
	setupgui)	build_setupgui;;
	installgui) build_installgui;;
	addusergui)	build_addusergui;;
	dmconfig)	build_dmconfig;;
	chusr)		build_chusr;;
	src)		instsrcdist;;
	update)		updatebase;;
	*)			usage;;
	esac
	shift
done
